<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VV2 Discord LP Tracker</title>

  <!-- D3.js Library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Style -->
  <style>
    body {
      background-color: #121212; /* Dark background */
      color: #ffffff;            /* White text */
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    h1 {
      text-align: center;
      margin: 20px 0;
    }

    /* We'll create a container for the chart */
    #chart {
      display: block;
      margin: 0 auto;
      /* Decrease width from 95vw to 90vw to leave space on the right */
      width: 80vw;
      height: 90vh;
      position: relative; /* so we can position tooltip absolutely */
    }

    /* Our tooltip */
    .tooltip {
      position: absolute;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      pointer-events: none; /* ignore mouse so as not to block hover */
      font-size: 0.85rem;
      font-family: Arial, sans-serif;
      visibility: hidden;   /* hidden by default */
    }
  </style>
</head>
<body>
  <h1>VV2 Discord LP Tracker</h1>
  <div id="chart"></div>

  <script>
    async function loadData() {
      // 1) Load your JSON file
      const response = await fetch("lp_data.json");
      const data = await response.json();

      // 2) Extract cutoff values
      const CHALLENGER_CUTOFF = data.cutoffs.CHALLENGER;
      const GRANDMASTER_CUTOFF = data.cutoffs.GRANDMASTER;

      // Master baseline
      const MASTER_BASE = 2800;

      // Compute GM and Challenger cutoffs
      const gm = MASTER_BASE + GRANDMASTER_CUTOFF;
      const chall = MASTER_BASE + CHALLENGER_CUTOFF;

      // Ranks below Master
      const ranks = [
        "IRON",      // index 0 => 0..400
        "BRONZE",    // index 1 => 400..800
        "SILVER",    // index 2 => 800..1200
        "GOLD",      // index 3 => 1200..1600
        "PLATINUM",  // index 4 => 1600..2000
        "EMERALD",   // index 5 => 2000..2400
        "DIAMOND",   // index 6 => 2400..2800
        "MASTER"     // index 7 => 2800..gm
      ];

      // Division offsets
      const divisionOffset = {
        "IV": 300,
        "III": 200,
        "II": 100,
        "I": 0
      };

      // 3) Convert the data into an array of summoners
      const summonerNames = Object.keys(data.summoners);

      // We'll figure out earliest and latest dates across all summoners
      let allPoints = [];

      const summoners = summonerNames.map((summoner) => {
        const records = data.summoners[summoner];

        // Build the array of data points for this summoner
        let points = records.map((record) => {
          let adjustedLP = 0;

          // Determine adjusted LP based on rank
          if (record.tier === "CHALLENGER") {
            adjustedLP = MASTER_BASE + record.lp; 
          }
          else if (record.tier === "GRANDMASTER") {
            adjustedLP = MASTER_BASE + record.lp;
          }
          else if (record.tier === "MASTER") {
            adjustedLP = MASTER_BASE + record.lp;
          }
          else {
            // IRON -> DIAMOND
            const rankIndex = ranks.indexOf(record.tier); 
            const baseLP = 400 * rankIndex;
            const divOff = 300 - (divisionOffset[record.rank] || 0);
            adjustedLP = baseLP + divOff + record.lp;
          }

          // Return the data point, plus tier and division for the tooltip
          return {
            x: new Date(record.timestamp),
            y: adjustedLP,
            realLP: record.lp,
            tier: record.tier,   // e.g. "GOLD"
            division: record.rank // e.g. "III"
          };
        });

        // Sort points by date ascending
        points.sort((a, b) => a.x - b.x);

        // Collect in allPoints for domain calculation
        allPoints = allPoints.concat(points);

        return {
          name: summoner,
          points,
          latestTier: `${records[records.length - 1].tier} ${records[records.length - 1].rank}`
        };
      });

      // 4) Determine earliest and latest actual data date
      const earliestDate = d3.min(allPoints, d => d.x);
      const latestDate = d3.max(allPoints, d => d.x);

      // 5) Expand domain to "earliestDate - 2 days" and "latestDate + 1 day"
      const domainStart = d3.timeDay.offset(earliestDate, -2);
      const domainEnd   = d3.timeDay.offset(latestDate, +1);

      // 6) Dimensions & margins
      const container = document.getElementById('chart');
      const width = container.clientWidth;
      const height = container.clientHeight;

      // Increase the right margin for the legend
      const margin = { top: 20, right: 200, bottom: 50, left: 60 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // 7) Create the SVG
      const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      // 8) Main group
      const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // 9) x-scale: time
      const xScale = d3.scaleTime()
        .domain([domainStart, domainEnd])
        .range([0, innerWidth]);

      // 10) y-scale
      const yScale = d3.scaleLinear()
        .domain([0, 4400])
        .range([innerHeight, 0]);

      // 11) Y-axis ticks
      const tickVals = [];
      for (let val = 0; val <= 2800; val += 400) {
        tickVals.push(val);
      }
      tickVals.push(gm, chall);
      tickVals.sort((a, b) => a - b);
      const uniqueTicks = [...new Set(tickVals)];

      // 12) Y-axis
      const yAxis = d3.axisLeft(yScale)
        .tickValues(uniqueTicks)
        .tickFormat(value => {
          if (value >= chall) return "CHALL";
          else if (value >= gm) return "GM";
          else if (value >= MASTER_BASE) return "MASTER";
          else {
            const idx = Math.floor(value / 400);
            return ranks[idx] || "";
          }
        });

      // 13) X-axis (daily ticks)
      const xAxis = d3.axisBottom(xScale)
        .ticks(d3.timeDay.every(1))
        .tickFormat(d3.timeFormat("%b %d"));

      // Render y-axis
      g.append("g")
        .attr("class", "y-axis")
        .call(yAxis)
        .selectAll("text")
        .attr("fill", "#ffffff");

      // Render x-axis
      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxis)
        .selectAll("text")
        .attr("fill", "#ffffff");

      // Style axis lines
      g.selectAll(".domain, .tick line")
        .attr("stroke", "rgba(255,255,255,0.2)");

      // 14) D3 line generator
      const lineGen = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y))
        .curve(d3.curveLinear);

      // 15) Color scale
      const color = d3.scaleOrdinal()
        .domain(summonerNames)
        .range(["blue", "red", "green", "orange", "purple",
                "cyan", "magenta", "teal", "pink", "yellow"]);

      // 16) Insert a "fake" point at domainStart if needed
      summoners.forEach(s => {
        const pts = s.points;
        if (pts.length) {
          const earliestPt = pts[0];
          if (domainStart < earliestPt.x) {
            // Clone the earliest point but change the x to domainStart
            pts.unshift({
              x: domainStart,
              y: earliestPt.y,
              realLP: earliestPt.realLP,
              tier: earliestPt.tier,
              division: earliestPt.division
            });
          }
        }
      });

      // 17) Draw lines FIRST (so they don't intercept events on circles)
      summoners.forEach(s => {
        g.append("path")
          .datum(s.points)
          .attr("fill", "none")
          .attr("stroke", color(s.name))
          .attr("stroke-width", 2)
          // Ensures the path won't block mouse events on circles
          .attr("pointer-events", "none")
          .attr("d", lineGen);
      });

      // 18) Draw circles for each data point (on top),
      //     but sanitize summoner name to avoid invalid selectors.
      summoners.forEach(s => {
        // Replace invalid CSS selector chars with underscores
        const safeName = s.name.replace(/[^a-zA-Z0-9_-]/g, "_");

        g.selectAll(`.circle-${safeName}`)
          .data(s.points)
          .enter()
          .append("circle")
          .attr("class", `circle-${safeName}`)
          .attr("cx", d => xScale(d.x))
          .attr("cy", d => yScale(d.y))
          .attr("r", 5)
          .attr("fill", color(s.name));
      });

      // 19) Tooltip
      const tooltip = d3.select("#chart")
        .append("div")
        .attr("class", "tooltip");

      // 20) Mouse events (again use the safeName)
      summoners.forEach(s => {
        const safeName = s.name.replace(/[^a-zA-Z0-9_-]/g, "_");

        g.selectAll(`.circle-${safeName}`)
          .on("mouseover", (event, d) => {
            tooltip
              .style("visibility", "visible")
              .html(`
                <strong>${s.name}</strong><br>
                ${d.tier} ${d.division}<br>
                ${d.realLP} LP<br>
                ${d.x.toDateString()}
              `);
          })
          .on("mousemove", event => {
            tooltip
              .style("top", (event.pageY - 40) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });
      });

      // 21) Legend
      // Move the legend to the far right, beyond the plot area
      const legend = g.selectAll(".legend")
        .data(summoners)
        .enter()
        .append("g")
        // +10 to the 'innerWidth' so it sits in the extra margin space
        .attr("transform", (d, i) => `translate(${innerWidth + 10}, ${i * 20})`);

      legend.append("rect")
        .attr("width", 12)
        .attr("height", 12)
        .attr("fill", d => color(d.name));

      legend.append("text")
        .attr("x", 18)
        .attr("y", 10)
        .attr("fill", "#ffffff")
        .style("font-size", "0.85rem")
        .text(d => `${d.name} (${d.latestTier})`);
    }

    // Kick off data loading and chart rendering
    loadData();
  </script>
</body>
</html>