<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Summoner Progression Tracker (D3.js)</title>

  <!-- D3.js Library -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- Style -->
  <style>
    body {
      background-color: #121212; /* Dark background */
      color: #ffffff;            /* White text */
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    h1 {
      text-align: center;
      margin: 20px 0;
    }

    /* We'll create a container for the chart */
    #chart {
      display: block;
      margin: 0 auto;
      width: 95vw;  /* nearly full screen width */
      height: 90vh; /* nearly full screen height */
      position: relative; /* so we can position tooltip absolutely */
    }

    /* Our tooltip */
    .tooltip {
      position: absolute;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      pointer-events: none; /* ignore mouse so as not to block hover */
      font-size: 0.85rem;
      font-family: Arial, sans-serif;
      visibility: hidden;   /* hidden by default */
    }
  </style>
</head>
<body>
  <h1>Summoner Progression Tracker (D3.js)</h1>
  <div id="chart"></div>

  <script>
    async function loadData() {
      // 1) Load your JSON file
      const response = await fetch("lp_data.json");
      const data = await response.json();

      // 2) Extract cutoff values
      const CHALLENGER_CUTOFF = data.cutoffs.CHALLENGER;   // e.g. 500
      const GRANDMASTER_CUTOFF = data.cutoffs.GRANDMASTER; // e.g. 200

      // Master baseline
      const MASTER_BASE = 2800;

      // Compute the exact positions for GM and Challenger
      const gm = MASTER_BASE + GRANDMASTER_CUTOFF;
      const chall = MASTER_BASE + CHALLENGER_CUTOFF;

      // Tiers used below Master
      const ranks = [
        "IRON",      // index 0 => 0..400
        "BRONZE",    // index 1 => 400..800
        "SILVER",    // index 2 => 800..1200
        "GOLD",      // index 3 => 1200..1600
        "PLATINUM",  // index 4 => 1600..2000
        "EMERALD",   // index 5 => 2000..2400
        "DIAMOND",   // index 6 => 2400..2800
        "MASTER"     // index 7 => 2800..gm
      ];

      // Division offsets
      const divisionOffset = {
        "IV": 300,
        "III": 200,
        "II": 100,
        "I": 0
      };

      // 3) Convert data into an array of summoners
      // data.summoners should be an object keyed by summoner name
      // We'll transform it into an array for easier handling in D3.
      // Each element will look like:
      // {
      //   name: summonerName,
      //   points: [
      //     { x: Date, y: Number, realLP: Number },
      //     ...
      //   ]
      // }
      const summonerNames = Object.keys(data.summoners);
      const summoners = summonerNames.map((summoner) => {
        const records = data.summoners[summoner];
        const points = records.map((record) => {
          let adjustedLP = 0;

          // Figure out adjusted LP
          if (record.tier === "CHALLENGER") {
            adjustedLP = chall + record.lp;
          } 
          else if (record.tier === "GRANDMASTER") {
            adjustedLP = gm + record.lp;
          } 
          else if (record.tier === "MASTER") {
            adjustedLP = MASTER_BASE + record.lp;
          } 
          else {
            const rankIndex = ranks.indexOf(record.tier); 
            const baseLP = 400 * (rankIndex + 1);
            const divOff = 300 - (divisionOffset[record.rank] || 0);
            adjustedLP = baseLP + divOff + record.lp;
          }

          return {
            x: new Date(record.timestamp),
            y: adjustedLP,
            realLP: record.lp
          };
        });

        return {
          name: summoner,
          latestTier: `${records[records.length - 1].tier} ${records[records.length - 1].rank}`,
          points
        };
      });

      // 4) Determine min/max dates across all summoners to set x-axis domain
      let allPoints = [];
      summoners.forEach(s => allPoints = allPoints.concat(s.points));

      const minDate = d3.min(allPoints, d => d.x);
      const maxDate = d3.max(allPoints, d => d.x);

      // 5) Dimensions & margins for the SVG
      // We can use the #chart div's width/height, or pick a static size
      const container = document.getElementById('chart');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const margin = { top: 20, right: 30, bottom: 50, left: 60 };
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;

      // 6) Create an SVG inside #chart
      const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      // 7) Scales
      // x-scale: time
      const xScale = d3.scaleTime()
        .domain([minDate, maxDate])
        .range([0, innerWidth]);

      // y-scale: linear from 0..4400
      const yScale = d3.scaleLinear()
        .domain([0, 4400])
        .range([innerHeight, 0]);

      // 8) Create a group (g) that we'll translate for margins
      const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // 9) Build custom tick values for y-axis:
      //    multiples of 400 from 0..2800, plus gm & chall
      const tickVals = [];
      for (let val = 0; val <= 2800; val += 400) {
        tickVals.push(val);
      }
      tickVals.push(gm, chall);
      tickVals.sort((a, b) => a - b);
      const uniqueTicks = Array.from(new Set(tickVals)); // remove duplicates

      // 10) Y-axis with custom tick format
      const yAxis = d3.axisLeft(yScale)
        .tickValues(uniqueTicks)
        .tickFormat(value => {
          if (value >= chall) return "CHALLENGER";
          else if (value >= gm) return "GRANDMASTER";
          else if (value >= MASTER_BASE) return "MASTER";
          else {
            // For IRON -> DIAMOND
            const idx = Math.floor(value / 400);
            return ranks[idx] || "";
          }
        });

      // 11) X-axis (time)
      const xAxis = d3.axisBottom(xScale)
        .ticks(d3.timeDay.every(1)) // daily ticks, adjust as needed
        .tickFormat(d3.timeFormat("%b %d")); // e.g. "Jan 01"

      // 12) Render axes
      g.append("g")
        .attr("class", "y-axis")
        .call(yAxis)
        .selectAll("text")
        .attr("fill", "#ffffff");   // White text

      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${innerHeight})`)
        .call(xAxis)
        .selectAll("text")
        .attr("fill", "#ffffff");

      // 13) Axis lines color
      g.selectAll(".domain, .tick line")
        .attr("stroke", "rgba(255,255,255,0.2)");

      // 14) Create line generator
      const lineGen = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y))
        .curve(d3.curveLinear); // or d3.curveMonotoneX, etc.

      // 15) A color scale for summoners
      const color = d3.scaleOrdinal()
        .domain(summonerNames)
        .range(["blue", "red", "green", "orange", "purple",
                "cyan", "magenta", "teal", "pink", "yellow"]);

      // 16) Draw lines for each summoner
      summoners.forEach(s => {
        g.append("path")
          .datum(s.points)
          .attr("fill", "none")
          .attr("stroke", color(s.name))
          .attr("stroke-width", 2)
          .attr("d", lineGen);
      });

      // 17) Draw circles for each data point + add a "title" or a real tooltip
      summoners.forEach(s => {
        g.selectAll(`.circle-${s.name}`)
          .data(s.points)
          .enter()
          .append("circle")
          .attr("class", `circle-${s.name}`)
          .attr("cx", d => xScale(d.x))
          .attr("cy", d => yScale(d.y))
          .attr("r", 4)
          .attr("fill", color(s.name));
      });

      // 18) Create a tooltip div
      const tooltip = d3.select("#chart")
        .append("div")
        .attr("class", "tooltip");

      // 19) Add mouse events for each circle to show/hide tooltip
      summoners.forEach(s => {
        g.selectAll(`.circle-${s.name}`)
          .on("mouseover", (event, d) => {
            tooltip
              .style("visibility", "visible")
              .html(`<strong>${s.name}</strong><br>${d.realLP} LP<br>${d.x.toDateString()}`);
          })
          .on("mousemove", event => {
            // position the tooltip near the mouse
            tooltip
              .style("top", (event.pageY - 40) + "px")
              .style("left", (event.pageX + 10) + "px");
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });
      });

      // 20) Optionally, create a legend
      const legend = g.selectAll(".legend")
        .data(summoners)
        .enter()
        .append("g")
        .attr("transform", (d, i) => `translate(${innerWidth - 120}, ${i * 20})`);

      legend.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 12)
        .attr("height", 12)
        .attr("fill", d => color(d.name));

      legend.append("text")
        .attr("x", 18)
        .attr("y", 10)
        .attr("fill", "#ffffff")
        .style("font-size", "0.85rem")
        .text(d => `${d.name} (${d.latestTier})`);
    }

    // Kick off data loading and chart rendering
    loadData();
  </script>
</body>
</html>